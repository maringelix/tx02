name: ğŸ›¡ï¸ Deploy Security Infrastructure (cert-manager + WAF)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - prd
          - stg
        default: prd
      install_cert_manager:
        description: 'Install cert-manager for automatic HTTPS'
        required: true
        type: boolean
        default: true
      letsencrypt_email:
        description: 'Email for Let''s Encrypt notifications'
        required: true
        default: 'admin@example.com'
      domain_name:
        description: 'Domain name for HTTPS certificate (e.g., dx02.no-ip.org)'
        required: true
        default: 'dx02.example.com'
      use_letsencrypt_prod:
        description: 'Use Let''s Encrypt Production (false = staging)'
        required: true
        type: boolean
        default: false
      deploy_app_gateway:
        description: 'Deploy Azure Application Gateway with WAF'
        required: true
        type: boolean
        default: false
      app_gateway_sku:
        description: 'Application Gateway SKU'
        required: true
        type: choice
        options:
          - WAF_v2
          - Standard_v2
        default: WAF_v2
      waf_mode:
        description: 'WAF Mode'
        required: true
        type: choice
        options:
          - Prevention
          - Detection
        default: Detection

permissions:
  contents: read
  id-token: write

env:
  AZURE_RESOURCE_GROUP: tx02-${{ github.event.inputs.environment }}-rg
  AKS_CLUSTER_NAME: tx02-${{ github.event.inputs.environment }}-aks
  LOCATION: eastus
  APP_GATEWAY_NAME: tx02-${{ github.event.inputs.environment }}-appgw
  VNET_NAME: tx02-${{ github.event.inputs.environment }}-vnet
  APP_GATEWAY_SUBNET: tx02-${{ github.event.inputs.environment }}-subnet-appgw

jobs:
  deploy-cert-manager:
    name: ğŸ“œ Deploy cert-manager
    runs-on: ubuntu-latest
    if: github.event.inputs.install_cert_manager == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ” Check if cert-manager is already installed
        id: check-cert-manager
        continue-on-error: true
        run: |
          if kubectl get namespace cert-manager &> /dev/null; then
            echo "installed=true" >> $GITHUB_OUTPUT
            echo "âœ… cert-manager jÃ¡ estÃ¡ instalado"
          else
            echo "installed=false" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ cert-manager nÃ£o estÃ¡ instalado"
          fi

      - name: ğŸ“¦ Install cert-manager using Helm
        if: steps.check-cert-manager.outputs.installed == 'false'
        run: |
          echo "ğŸ“¦ Installing cert-manager..."
          
          # Add Jetstack Helm repository
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          
          # Install cert-manager with CRDs
          helm install cert-manager jetstack/cert-manager \
            --namespace cert-manager \
            --create-namespace \
            --version v1.14.0 \
            --set installCRDs=true \
            --set global.leaderElection.namespace=cert-manager \
            --wait --timeout=5m
          
          echo "âœ… cert-manager installed successfully"

      - name: â³ Wait for cert-manager to be ready
        run: |
          echo "â³ Waiting for cert-manager pods to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=300s
          echo "âœ… cert-manager is ready"

      - name: ğŸ”‘ Create ClusterIssuer for Let's Encrypt
        run: |
          LETSENCRYPT_SERVER="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'https://acme-v02.api.letsencrypt.org/directory' || 'https://acme-staging-v02.api.letsencrypt.org/directory' }}"
          ISSUER_NAME="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'letsencrypt-prod' || 'letsencrypt-staging' }}"
          
          echo "ğŸ”‘ Creating ClusterIssuer: $ISSUER_NAME"
          echo "ğŸ“§ Email: ${{ github.event.inputs.letsencrypt_email }}"
          echo "ğŸŒ Server: $LETSENCRYPT_SERVER"
          
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: $ISSUER_NAME
          spec:
            acme:
              server: $LETSENCRYPT_SERVER
              email: ${{ github.event.inputs.letsencrypt_email }}
              privateKeySecretRef:
                name: $ISSUER_NAME-account-key
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF
          
          echo "âœ… ClusterIssuer created: $ISSUER_NAME"

      - name: ğŸ« Create sample certificate for testing
        run: |
          ISSUER_NAME="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'letsencrypt-prod' || 'letsencrypt-staging' }}"
          
          echo "ğŸ« Creating test certificate in dx02 namespace..."
          
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: Certificate
          metadata:
            name: dx02-tls-cert
            namespace: dx02
          spec:
            secretName: dx02-tls-secret
            issuerRef:
              name: $ISSUER_NAME
              kind: ClusterIssuer
            dnsNames:
            - ${{ github.event.inputs.domain_name }}
          EOF
          
          echo "âœ… Certificate created for domain: ${{ github.event.inputs.domain_name }}"
          echo "âš ï¸  Make sure DNS points to: 48.194.53.219"

      - name: ğŸ“Š Verify cert-manager installation
        run: |
          echo "======================================"
          echo "ğŸ“œ cert-manager Installation Summary"
          echo "======================================"
          echo ""
          
          echo "ğŸ“¦ cert-manager Pods:"
          kubectl get pods -n cert-manager
          echo ""
          
          echo "ğŸ”‘ ClusterIssuers:"
          kubectl get clusterissuer
          echo ""
          
          echo "ğŸ« Certificates:"
          kubectl get certificate --all-namespaces
          echo ""
          
          echo "âœ… cert-manager is ready to issue certificates!"

  deploy-application-gateway:
    name: ğŸ›¡ï¸ Deploy Application Gateway with WAF
    runs-on: ubuntu-latest
    if: github.event.inputs.deploy_app_gateway == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ” Check if Application Gateway exists
        id: check-appgw
        continue-on-error: true
        run: |
          if az network application-gateway show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Application Gateway jÃ¡ existe"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ Application Gateway nÃ£o existe"
          fi

      - name: ğŸŒ Verify subnet for Application Gateway
        if: steps.check-appgw.outputs.exists == 'false'
        run: |
          echo "ğŸŒ Verifying subnet for Application Gateway..."
          
          # Check if subnet already exists
          if az network vnet subnet show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --vnet-name ${{ env.VNET_NAME }} \
            --name ${{ env.APP_GATEWAY_SUBNET }} &> /dev/null; then
            echo "âœ… Subnet '${{ env.APP_GATEWAY_SUBNET }}' already exists"
            
            SUBNET_PREFIX=$(az network vnet subnet show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --vnet-name ${{ env.VNET_NAME }} \
              --name ${{ env.APP_GATEWAY_SUBNET }} \
              --query addressPrefix -o tsv)
            echo "   Address prefix: $SUBNET_PREFIX"
          else
            echo "âŒ Subnet does not exist. Creating with address prefix 10.0.5.0/24..."
            az network vnet subnet create \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --vnet-name ${{ env.VNET_NAME }} \
              --name ${{ env.APP_GATEWAY_SUBNET }} \
              --address-prefixes 10.0.5.0/24
            
            echo "âœ… Subnet created"
          fi

      - name: ğŸŒ Check Public IP Availability and Determine Strategy
        id: check-ip-strategy
        if: steps.check-appgw.outputs.exists == 'false'
        run: |
          echo "ğŸŒ Checking public IP availability..."
          
          # Get AKS managed resource group
          AKS_MC_RG=$(az aks show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --query nodeResourceGroup -o tsv)
          
          echo "AKS Managed Resource Group: $AKS_MC_RG"
          
          # Count existing public IPs in the region
          TOTAL_IPS=$(az network public-ip list \
            --query "[?location=='${{ env.LOCATION }}'] | length(@)" -o tsv)
          
          echo "Existing Public IPs in ${{ env.LOCATION }}: $TOTAL_IPS"
          
          # Azure Free Trial limit is 3 public IPs per region
          IP_LIMIT=3
          
          if [ $TOTAL_IPS -lt $IP_LIMIT ]; then
            echo "âœ… Public IP quota available ($TOTAL_IPS/$IP_LIMIT)"
            echo "strategy=create_new" >> $GITHUB_OUTPUT
            echo "reuse_ip=false" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸  Public IP limit reached ($TOTAL_IPS/$IP_LIMIT)"
            echo "ğŸ” Looking for NGINX Ingress LoadBalancer IP to reuse..."
            
            # Get NGINX Ingress LoadBalancer service
            NGINX_SVC=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o json 2>/dev/null || echo "{}")
            NGINX_IP=$(echo "$NGINX_SVC" | jq -r '.status.loadBalancer.ingress[0].ip // empty')
            
            if [ -n "$NGINX_IP" ] && [ "$NGINX_IP" != "null" ]; then
              echo "âœ… Found NGINX Ingress IP: $NGINX_IP"
              
              # Find the public IP resource for this IP address
              PUBLIC_IP_INFO=$(az network public-ip list \
                --query "[?ipAddress=='$NGINX_IP'] | [0].{name:name, resourceGroup:resourceGroup, id:id}" -o json)
              
              PUBLIC_IP_NAME=$(echo "$PUBLIC_IP_INFO" | jq -r '.name // empty')
              PUBLIC_IP_RG=$(echo "$PUBLIC_IP_INFO" | jq -r '.resourceGroup // empty')
              PUBLIC_IP_ID=$(echo "$PUBLIC_IP_INFO" | jq -r '.id // empty')
              
              if [ -n "$PUBLIC_IP_NAME" ] && [ "$PUBLIC_IP_NAME" != "null" ]; then
                echo "âœ… Found Public IP resource: $PUBLIC_IP_NAME"
                echo "   Resource Group: $PUBLIC_IP_RG"
                echo "   IP Address: $NGINX_IP"
                echo ""
                echo "ğŸ“‹ Strategy: Reuse NGINX Ingress public IP for Application Gateway"
                echo "âš ï¸  Note: NGINX Ingress will need to be reconfigured to NodePort type"
                
                echo "strategy=reuse_nginx" >> $GITHUB_OUTPUT
                echo "reuse_ip=true" >> $GITHUB_OUTPUT
                echo "ip_address=$NGINX_IP" >> $GITHUB_OUTPUT
                echo "ip_name=$PUBLIC_IP_NAME" >> $GITHUB_OUTPUT
                echo "ip_resource_group=$PUBLIC_IP_RG" >> $GITHUB_OUTPUT
                echo "ip_id=$PUBLIC_IP_ID" >> $GITHUB_OUTPUT
              else
                echo "âŒ Could not find public IP resource for $NGINX_IP"
                echo "strategy=failed" >> $GITHUB_OUTPUT
                exit 1
              fi
            else
              echo "âŒ Could not find NGINX Ingress LoadBalancer IP"
              echo "strategy=failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

      - name: ğŸ”„ Convert NGINX Ingress to NodePort (if reusing IP)
        if: steps.check-appgw.outputs.exists == 'false' && steps.check-ip-strategy.outputs.reuse_ip == 'true'
        run: |
          echo "ğŸ”„ Converting NGINX Ingress from LoadBalancer to NodePort..."
          echo "âš ï¸  This will release the public IP so Application Gateway can use it"
          
          # Patch NGINX Ingress service to NodePort type
          # This will delete the LoadBalancer and release the public IP
          kubectl patch svc ingress-nginx-controller -n ingress-nginx -p '{"spec":{"type":"NodePort"}}'
          
          # Wait for the LoadBalancer to be deleted and IP to be released
          echo "â³ Waiting 60 seconds for LoadBalancer to be deleted and IP to be released..."
          sleep 60
          
          # Verify the change
          SVC_TYPE=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.spec.type}')
          echo "âœ… NGINX Ingress service type: $SVC_TYPE"
          
          # Get NodePorts
          HTTP_NODEPORT=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.spec.ports[?(@.name=="http")].nodePort}')
          HTTPS_NODEPORT=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.spec.ports[?(@.name=="https")].nodePort}')
          
          echo "NodePorts: HTTP=$HTTP_NODEPORT, HTTPS=$HTTPS_NODEPORT"
          echo "http_nodeport=$HTTP_NODEPORT" >> $GITHUB_OUTPUT
          echo "https_nodeport=$HTTPS_NODEPORT" >> $GITHUB_OUTPUT
          
          # Verify IP is released
          echo "ğŸ” Verifying public IP status..."
          PUBLIC_IP_NAME="${{ steps.check-ip-strategy.outputs.ip_name }}"
          PUBLIC_IP_RG="${{ steps.check-ip-strategy.outputs.ip_resource_group }}"
          
          IP_CONFIG=$(az network public-ip show \
            --name $PUBLIC_IP_NAME \
            --resource-group $PUBLIC_IP_RG \
            --query ipConfiguration -o tsv 2>/dev/null || echo "")
          
          if [ -z "$IP_CONFIG" ] || [ "$IP_CONFIG" == "null" ]; then
            echo "âœ… Public IP is released and available for Application Gateway"
          else
            echo "âš ï¸  Public IP still associated, waiting additional 30 seconds..."
            sleep 30
          fi

      - name: ğŸ”„ Move Public IP to Application Gateway Resource Group (if reusing)
        id: move-public-ip
        if: steps.check-appgw.outputs.exists == 'false' && steps.check-ip-strategy.outputs.reuse_ip == 'true'
        run: |
          echo "ğŸ”„ Moving Public IP to Application Gateway resource group..."
          
          PUBLIC_IP_NAME="${{ steps.check-ip-strategy.outputs.ip_name }}"
          SOURCE_RG="${{ steps.check-ip-strategy.outputs.ip_resource_group }}"
          TARGET_RG="${{ env.AZURE_RESOURCE_GROUP }}"
          
          if [ "$SOURCE_RG" != "$TARGET_RG" ]; then
            echo "Moving $PUBLIC_IP_NAME from $SOURCE_RG to $TARGET_RG..."
            
            # Get the public IP resource ID
            IP_RESOURCE_ID=$(az network public-ip show \
              --name $PUBLIC_IP_NAME \
              --resource-group $SOURCE_RG \
              --query id -o tsv)
            
            # Move the resource
            az resource move \
              --ids $IP_RESOURCE_ID \
              --destination-group $TARGET_RG
            
            echo "âœ… Public IP moved to $TARGET_RG"
            
            # Wait for move to complete
            sleep 10
            
            # Update the resource group in outputs
            echo "ip_resource_group=$TARGET_RG" >> $GITHUB_OUTPUT
          else
            echo "âœ… Public IP already in correct resource group"
            echo "ip_resource_group=$SOURCE_RG" >> $GITHUB_OUTPUT
          fi

      - name: ğŸŒ Create New Public IP for Application Gateway
        id: create-new-ip
        if: steps.check-appgw.outputs.exists == 'false' && steps.check-ip-strategy.outputs.strategy == 'create_new'
        run: |
          echo "ğŸŒ Creating new Public IP for Application Gateway..."
          
          az network public-ip create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-pip \
            --location ${{ env.LOCATION }} \
            --allocation-method Static \
            --sku Standard \
            --tags Environment=${{ github.event.inputs.environment }} ManagedBy=GitHub-Actions
          
          IP_ADDRESS=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-pip \
            --query ipAddress -o tsv)
          
          echo "ip_address=$IP_ADDRESS" >> $GITHUB_OUTPUT
          echo "ip_name=${{ env.APP_GATEWAY_NAME }}-pip" >> $GITHUB_OUTPUT
          echo "ip_resource_group=${{ env.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
          
          echo "âœ… Public IP created:"
          echo "   Name: ${{ env.APP_GATEWAY_NAME }}-pip"
          echo "   IP: $IP_ADDRESS"
          echo ""
          echo "âš ï¸  IMPORTANTE: Update DNS dx02.ddns.net to new IP: $IP_ADDRESS"

      - name: ğŸ“‹ Set Public IP for Application Gateway
        id: get-ip
        if: steps.check-appgw.outputs.exists == 'false'
        run: |
          # Determine which IP to use based on strategy
          if [ "${{ steps.check-ip-strategy.outputs.strategy }}" == "create_new" ]; then
            echo "Using newly created public IP"
            echo "ip_address=${{ steps.create-new-ip.outputs.ip_address }}" >> $GITHUB_OUTPUT
            echo "ip_name=${{ steps.create-new-ip.outputs.ip_name }}" >> $GITHUB_OUTPUT
            echo "ip_resource_group=${{ steps.create-new-ip.outputs.ip_resource_group }}" >> $GITHUB_OUTPUT
          elif [ "${{ steps.check-ip-strategy.outputs.strategy }}" == "reuse_nginx" ]; then
            echo "Using NGINX Ingress public IP (moved to Application Gateway RG)"
            # Use the updated resource group from the move step
            UPDATED_RG="${{ steps.move-public-ip.outputs.ip_resource_group }}"
            if [ -z "$UPDATED_RG" ]; then
              UPDATED_RG="${{ env.AZURE_RESOURCE_GROUP }}"
            fi
            echo "ip_address=${{ steps.check-ip-strategy.outputs.ip_address }}" >> $GITHUB_OUTPUT
            echo "ip_name=${{ steps.check-ip-strategy.outputs.ip_name }}" >> $GITHUB_OUTPUT
            echo "ip_resource_group=$UPDATED_RG" >> $GITHUB_OUTPUT
          fi
          
          echo "âœ… Public IP determined:"
          echo "   Strategy: ${{ steps.check-ip-strategy.outputs.strategy }}"
          echo "   IP Address: ${{ steps.check-ip-strategy.outputs.ip_address || steps.create-new-ip.outputs.ip_address }}"

      - name: ğŸ›¡ï¸ Create WAF Policy (before Application Gateway)
        if: steps.check-appgw.outputs.exists == 'false' && github.event.inputs.app_gateway_sku == 'WAF_v2'
        run: |
          echo "ğŸ›¡ï¸ Creating WAF policy..."
          
          # Create WAF policy
          az network application-gateway waf-policy create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --location ${{ env.LOCATION }}
          
          # Configure WAF settings
          az network application-gateway waf-policy policy-setting update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --policy-name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --mode ${{ github.event.inputs.waf_mode }} \
            --state Enabled \
            --max-request-body-size-in-kb 128 \
            --file-upload-limit-in-mb 100
          
          echo "âœ… WAF policy created"

      - name: ğŸ›¡ï¸ Create Application Gateway with WAF
        if: steps.check-appgw.outputs.exists == 'false'
        run: |
          echo "ğŸ›¡ï¸ Creating Application Gateway with WAF..."
          echo "SKU: ${{ github.event.inputs.app_gateway_sku }}"
          echo "WAF Mode: ${{ github.event.inputs.waf_mode }}"
          echo "Strategy: ${{ steps.check-ip-strategy.outputs.strategy }}"
          
          # Get subnet ID
          SUBNET_ID=$(az network vnet subnet show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --vnet-name ${{ env.VNET_NAME }} \
            --name ${{ env.APP_GATEWAY_SUBNET }} \
            --query id -o tsv)
          
          # Use Public IP determined from previous steps
          echo "ğŸ”— Using Public IP: ${{ steps.get-ip.outputs.ip_address }}"
          PUBLIC_IP_NAME="${{ steps.get-ip.outputs.ip_name }}"
          PUBLIC_IP_RG="${{ steps.get-ip.outputs.ip_resource_group }}"
          
          # Get Public IP ID from the correct resource group
          PUBLIC_IP_ID=$(az network public-ip show \
            --resource-group $PUBLIC_IP_RG \
            --name $PUBLIC_IP_NAME \
            --query id -o tsv)
          echo "ğŸ”— Public IP ID: $PUBLIC_IP_ID"
          
          # Get WAF Policy ID if SKU is WAF_v2
          if [ "${{ github.event.inputs.app_gateway_sku }}" == "WAF_v2" ]; then
            WAF_POLICY_ID=$(az network application-gateway waf-policy show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
              --query id -o tsv)
            echo "ğŸ›¡ï¸ Using WAF Policy: $WAF_POLICY_ID"
            WAF_POLICY_ARG="--waf-policy $WAF_POLICY_ID"
          else
            WAF_POLICY_ARG=""
          fi
          
          # Create Application Gateway
          az network application-gateway create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --location ${{ env.LOCATION }} \
            --sku ${{ github.event.inputs.app_gateway_sku }} \
            --capacity 2 \
            --vnet-name ${{ env.VNET_NAME }} \
            --subnet $SUBNET_ID \
            --public-ip-address $PUBLIC_IP_ID \
            --http-settings-cookie-based-affinity Disabled \
            --frontend-port 80 \
            --http-settings-port 80 \
            --http-settings-protocol Http \
            --priority 100 \
            $WAF_POLICY_ARG \
            --tags Environment=${{ github.event.inputs.environment }} ManagedBy=GitHub-Actions Strategy=${{ steps.check-ip-strategy.outputs.strategy }}
          
          echo "âœ… Application Gateway created"

      - name: ğŸ›¡ï¸ Verify WAF Policy association
        if: github.event.inputs.app_gateway_sku == 'WAF_v2'
        run: |
          echo "ğŸ›¡ï¸ Configuring WAF policy..."
          
          # Create WAF policy
          az network application-gateway waf-policy create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --location ${{ env.LOCATION }}
          
          # Configure WAF settings
          az network application-gateway waf-policy policy-setting update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --policy-name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --mode ${{ github.event.inputs.waf_mode }} \
            --state Enabled \
            --max-request-body-size-in-kb 128 \
            --file-upload-limit-in-mb 100
          
          # Associate WAF policy with Application Gateway
          az network application-gateway update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --set firewallPolicy.id=$(az network application-gateway waf-policy show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
              --query id -o tsv)
          
          echo "âœ… WAF policy configured"

      - name: ğŸ”§ Install AGIC (Application Gateway Ingress Controller)
        run: |
          echo "ğŸ”§ Installing AGIC..."
          
          # Enable AGIC add-on on AKS
          az aks enable-addons \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --addons ingress-appgw \
            --appgw-id $(az network application-gateway show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.APP_GATEWAY_NAME }} \
              --query id -o tsv) || echo "âš ï¸ AGIC may already be enabled"
          
          echo "âœ… AGIC configured"

      - name: ğŸ“Š Verify Application Gateway installation
        run: |
          echo "======================================"
          echo "ğŸ›¡ï¸ Application Gateway Summary"
          echo "======================================"
          echo ""
          
          echo "ğŸŒ Application Gateway:"
          az network application-gateway show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --query "{name:name,sku:sku.name,tier:sku.tier,capacity:sku.capacity,provisioningState:provisioningState}" \
            -o table
          echo ""
          
          echo "ğŸŒ Public IP (novo):"
          APPGW_IP=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-pip \
            --query ipAddress -o tsv)
          echo "IP Address: $APPGW_IP"
          echo ""
          echo "âš ï¸  IMPORTANTE: Atualize seu DNS!"
          echo "   dx02.ddns.net â†’ $APPGW_IP"
          echo ""
          
          echo "ğŸ›¡ï¸ WAF Policy:"
          az network application-gateway waf-policy show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --query "{name:name,mode:policySettings.mode,state:policySettings.state}" \
            -o table 2>/dev/null || echo "WAF policy not configured"
          echo ""
          
          echo "âœ… Application Gateway is ready!"

  configure-backend-pool:
    name: ğŸ”§ Configure Application Gateway Backend
    runs-on: ubuntu-latest
    needs: deploy-application-gateway
    if: |
      always() && 
      github.event.inputs.deploy_app_gateway == 'true' &&
      needs.deploy-application-gateway.result == 'success'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ” Get AKS Node IPs
        id: get-nodes
        run: |
          echo "ğŸ” Getting AKS node internal IPs..."
          NODE_IPS=$(kubectl get nodes -o jsonpath='{.items[*].status.addresses[?(@.type=="InternalIP")].address}' | tr ' ' ' ')
          echo "node_ips=$NODE_IPS" >> $GITHUB_OUTPUT
          echo "âœ… Node IPs: $NODE_IPS"

      - name: ğŸ” Get Nginx Ingress NodePorts
        id: get-nodeports
        run: |
          echo "ğŸ” Getting Nginx Ingress NodePorts..."
          HTTP_NODEPORT=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.spec.ports[?(@.port==80)].nodePort}')
          HTTPS_NODEPORT=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.spec.ports[?(@.port==443)].nodePort}')
          
          echo "http_nodeport=$HTTP_NODEPORT" >> $GITHUB_OUTPUT
          echo "https_nodeport=$HTTPS_NODEPORT" >> $GITHUB_OUTPUT
          
          echo "âœ… HTTP NodePort: $HTTP_NODEPORT"
          echo "âœ… HTTPS NodePort: $HTTPS_NODEPORT"

      - name: ğŸ”§ Update Backend Pool with Node IPs
        run: |
          echo "ğŸ”§ Updating Application Gateway backend pool..."
          az network application-gateway address-pool update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name appGatewayBackendPool \
            --servers ${{ steps.get-nodes.outputs.node_ips }}
          
          echo "âœ… Backend pool updated with node IPs"

      - name: ğŸ”§ Update HTTP Settings for HTTP (NodePort)
        run: |
          echo "ğŸ”§ Updating HTTP settings for NodePort ${{ steps.get-nodeports.outputs.http_nodeport }}..."
          az network application-gateway http-settings update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name appGatewayBackendHttpSettings \
            --port ${{ steps.get-nodeports.outputs.http_nodeport }} \
            --protocol Http \
            --timeout 30
          
          echo "âœ… HTTP settings updated"

      - name: ğŸ¥ Create Health Probe HTTP with Hostname
        run: |
          echo "ğŸ¥ Creating HTTP health probe..."
          az network application-gateway probe create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name dx02-health-probe \
            --protocol Http \
            --host ${{ github.event.inputs.domain_name }} \
            --path / \
            --interval 30 \
            --timeout 30 \
            --threshold 3 \
            || echo "âš ï¸ Health probe may already exist"
          
          echo "âœ… Health probe created"

      - name: ğŸ”— Associate Health Probe to HTTP Settings
        run: |
          echo "ğŸ”— Associating health probe to HTTP settings..."
          az network application-gateway http-settings update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name appGatewayBackendHttpSettings \
            --probe dx02-health-probe
          
          echo "âœ… Health probe associated"

      - name: â³ Wait for Backend Health Check
        run: |
          echo "â³ Waiting 60 seconds for backend health probes..."
          sleep 60

      - name: ğŸ¥ Verify Backend Health
        run: |
          echo "ğŸ¥ Checking backend health..."
          az network application-gateway show-backend-health \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --query 'backendAddressPools[0].backendHttpSettingsCollection[0].servers[*].{address:address, health:health}' \
            -o table
          
          echo "âœ… Backend health check complete"

  configure-ssl-certificate:
    name: ğŸ” Configure SSL Certificate
    runs-on: ubuntu-latest
    needs: [deploy-cert-manager, configure-backend-pool]
    if: |
      always() && 
      github.event.inputs.install_cert_manager == 'true' &&
      github.event.inputs.deploy_app_gateway == 'true' &&
      needs.deploy-cert-manager.result == 'success' &&
      needs.configure-backend-pool.result == 'success'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: â³ Wait for Certificate to be Ready
        run: |
          echo "â³ Waiting for certificate to be issued..."
          kubectl wait --for=condition=Ready certificate/dx02-tls \
            -n dx02 \
            --timeout=600s || echo "âš ï¸ Certificate may not be ready yet"
          
          echo "âœ… Checking certificate status..."
          kubectl get certificate -n dx02

      - name: ğŸ“œ Export Certificate from Kubernetes
        run: |
          echo "ğŸ“œ Exporting certificate from Kubernetes secret..."
          kubectl get secret dx02-tls -n dx02 \
            -o jsonpath='{.data.tls\.crt}' | base64 -d > tls.crt
          kubectl get secret dx02-tls -n dx02 \
            -o jsonpath='{.data.tls\.key}' | base64 -d > tls.key
          
          echo "âœ… Certificate exported"
          ls -lh tls.crt tls.key

      - name: ğŸ” Convert Certificate to PFX
        run: |
          echo "ğŸ” Converting certificate to PFX format..."
          openssl pkcs12 -export \
            -out dx02-tls.pfx \
            -inkey tls.key \
            -in tls.crt \
            -passout pass:${{ secrets.CERT_PASSWORD }}
          
          echo "âœ… Certificate converted to PFX"
          ls -lh dx02-tls.pfx

      - name: ï¿½ï¸ Remove Existing Self-Signed Certificate (if exists)
        run: |
          echo "ğŸ—‘ï¸ Checking for existing self-signed certificate..."
          if az network application-gateway ssl-cert show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name dx02-ssl-cert &>/dev/null; then
            
            echo "âš ï¸ Found existing certificate, removing..."
            # First, we need to check if listener is using this cert
            LISTENER_EXISTS=$(az network application-gateway http-listener show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --gateway-name ${{ env.APP_GATEWAY_NAME }} \
              --name httpsListener 2>/dev/null || echo "")
            
            if [ ! -z "$LISTENER_EXISTS" ]; then
              echo "ğŸ“‹ Updating listener to remove cert reference temporarily..."
              # Delete and recreate listener without cert
              az network application-gateway http-listener delete \
                --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                --gateway-name ${{ env.APP_GATEWAY_NAME }} \
                --name httpsListener
            fi
            
            # Now delete the certificate
            az network application-gateway ssl-cert delete \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --gateway-name ${{ env.APP_GATEWAY_NAME }} \
              --name dx02-ssl-cert
            
            echo "âœ… Old certificate removed"
          else
            echo "âœ… No existing certificate to remove"
          fi

      - name: ğŸ“¤ Upload Let's Encrypt Certificate to Application Gateway
        run: |
          echo "ğŸ“¤ Uploading Let's Encrypt SSL certificate to Application Gateway..."
          az network application-gateway ssl-cert create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name dx02-ssl-cert \
            --cert-file dx02-tls.pfx \
            --cert-password "${{ secrets.CERT_PASSWORD }}"
          
          echo "âœ… Let's Encrypt SSL certificate uploaded successfully"

      - name: ğŸ§¹ Cleanup temporary files
        if: always()
        run: |
          rm -f tls.crt tls.key dx02-tls.pfx
          echo "âœ… Temporary certificate files removed"

  configure-https-listener:
    name: ğŸ”Š Configure HTTPS Listener & Routing
    runs-on: ubuntu-latest
    needs: [configure-backend-pool, configure-ssl-certificate]
    if: |
      always() && 
      github.event.inputs.deploy_app_gateway == 'true' &&
      needs.configure-backend-pool.result == 'success' &&
      needs.configure-ssl-certificate.result == 'success'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ” Get HTTPS NodePort
        id: get-https-nodeport
        run: |
          HTTPS_NODEPORT=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.spec.ports[?(@.port==443)].nodePort}')
          echo "https_nodeport=$HTTPS_NODEPORT" >> $GITHUB_OUTPUT
          echo "âœ… HTTPS NodePort: $HTTPS_NODEPORT"

      - name: ğŸ”Œ Create Frontend Port 443
        run: |
          echo "ğŸ”Œ Creating frontend port 443..."
          az network application-gateway frontend-port create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name port443 \
            --port 443 \
            || echo "âš ï¸ Port 443 may already exist"
          
          echo "âœ… Frontend port 443 ready"

      - name: ğŸ”Š Create or Update HTTPS Listener
        run: |
          echo "ğŸ”Š Creating HTTPS listener..."
          
          # Check if port443 exists, create if not
          if ! az network application-gateway frontend-port show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name port443 &>/dev/null; then
            
            az network application-gateway frontend-port create \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --gateway-name ${{ env.APP_GATEWAY_NAME }} \
              --name port443 \
              --port 443
            echo "âœ… Frontend port 443 created"
          else
            echo "âœ… Frontend port 443 already exists"
          fi
          
          # Create HTTPS listener with Let's Encrypt certificate
          az network application-gateway http-listener create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name httpsListener \
            --frontend-port port443 \
            --frontend-ip appGatewayFrontendIP \
            --ssl-cert dx02-ssl-cert \
            --host-name ${{ github.event.inputs.domain_name }}
          
          echo "âœ… HTTPS listener created with Let's Encrypt certificate"

      - name: ğŸ¥ Create HTTPS Health Probe
        run: |
          echo "ğŸ¥ Creating HTTPS health probe..."
          az network application-gateway probe create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name dx02-https-probe \
            --protocol Https \
            --host ${{ github.event.inputs.domain_name }} \
            --path / \
            --interval 30 \
            --timeout 30 \
            --threshold 3 \
            || echo "âš ï¸ HTTPS health probe may already exist"
          
          echo "âœ… HTTPS health probe created"

      - name: ğŸ”§ Create HTTPS Backend Settings
        run: |
          echo "ğŸ”§ Creating HTTPS backend settings..."
          az network application-gateway http-settings create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name httpsBackendSettings \
            --port ${{ steps.get-https-nodeport.outputs.https_nodeport }} \
            --protocol Https \
            --timeout 30 \
            --probe dx02-https-probe \
            || echo "âš ï¸ HTTPS backend settings may already exist"
          
          echo "âœ… HTTPS backend settings created"

      - name: ğŸ”€ Create or Update HTTPS Routing Rule
        run: |
          echo "ğŸ”€ Creating HTTPS routing rule..."
          
          # Check if rule exists
          if az network application-gateway rule show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name httpsRule &>/dev/null; then
            
            echo "âš ï¸ Rule exists, updating..."
            az network application-gateway rule update \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --gateway-name ${{ env.APP_GATEWAY_NAME }} \
              --name httpsRule \
              --http-listener httpsListener \
              --address-pool appGatewayBackendPool \
              --http-settings httpsBackendSettings \
              --priority 200
          else
            echo "ğŸ“‹ Creating new rule..."
            az network application-gateway rule create \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --gateway-name ${{ env.APP_GATEWAY_NAME }} \
              --name httpsRule \
              --http-listener httpsListener \
              --address-pool appGatewayBackendPool \
              --http-settings httpsBackendSettings \
              --priority 200
          fi
          
          echo "âœ… HTTPS routing rule configured"

  validate-deployment:
    name: âœ… Validate Application Gateway Deployment
    runs-on: ubuntu-latest
    needs: [configure-backend-pool, configure-https-listener]
    if: |
      always() && 
      github.event.inputs.deploy_app_gateway == 'true' &&
      needs.configure-backend-pool.result == 'success' &&
      needs.configure-https-listener.result == 'success'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: â³ Wait for Configuration to Settle
        run: |
          echo "â³ Waiting 90 seconds for Application Gateway to process all changes..."
          sleep 90

      - name: ğŸ¥ Final Backend Health Check
        run: |
          echo "ğŸ¥ Checking final backend health status..."
          az network application-gateway show-backend-health \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --query 'backendAddressPools[0].backendHttpSettingsCollection[*].servers[*].{address:address, health:health, httpSettings:backendHttpSettings.id}' \
            -o table

      - name: ğŸ“Š Display Application Gateway Summary
        run: |
          echo "======================================"
          echo "ğŸ›¡ï¸ Application Gateway Configuration"
          echo "======================================"
          echo ""
          
          echo "ğŸ“‹ Backend Pools:"
          az network application-gateway address-pool list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            -o table
          echo ""
          
          echo "ğŸ”Š HTTP Listeners:"
          az network application-gateway http-listener list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --query '[].{Name:name, Protocol:protocol, Port:frontendPort.id, Hostname:hostName}' \
            -o table
          echo ""
          
          echo "ğŸ”€ Routing Rules:"
          az network application-gateway rule list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --query '[].{Name:name, Priority:priority, Listener:httpListener.id}' \
            -o table
          echo ""
          
          APPGW_IP=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-pip \
            --query ipAddress -o tsv)
          
          echo "======================================"
          echo "âœ… Application Gateway Ready!"
          echo "======================================"
          echo ""
          echo "ğŸŒ Public IP: $APPGW_IP"
          echo "ğŸ”— Test HTTP:  http://${{ github.event.inputs.domain_name }}"
          echo "ğŸ”’ Test HTTPS: https://${{ github.event.inputs.domain_name }}"
          echo ""
          echo "âš ï¸  IMPORTANTE: Certifique-se de que o DNS estÃ¡ configurado!"
          echo "   ${{ github.event.inputs.domain_name }} â†’ $APPGW_IP"

  configure-ingress:
    name: ğŸ”— Configure Ingress with HTTPS
    runs-on: ubuntu-latest
    needs: [deploy-cert-manager, deploy-application-gateway, validate-deployment]
    if: |
      always() && 
      (needs.deploy-cert-manager.result == 'success' || needs.deploy-cert-manager.result == 'skipped') &&
      (needs.deploy-application-gateway.result == 'success' || needs.deploy-application-gateway.result == 'skipped') &&
      (needs.validate-deployment.result == 'success' || needs.validate-deployment.result == 'skipped')
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ”— Update DX02 Ingress with HTTPS and cert-manager
        if: github.event.inputs.install_cert_manager == 'true'
        run: |
          ISSUER_NAME="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'letsencrypt-prod' || 'letsencrypt-staging' }}"
          
          echo "ğŸ”— Updating DX02 Ingress with HTTPS support..."
          echo "Domain: ${{ github.event.inputs.domain_name }}"
          
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: dx02
            namespace: dx02
            annotations:
              cert-manager.io/cluster-issuer: $ISSUER_NAME
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
              nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
              nginx.ingress.kubernetes.io/proxy-body-size: "10m"
              nginx.ingress.kubernetes.io/rate-limit: "100"
          spec:
            ingressClassName: nginx
            tls:
            - hosts:
              - ${{ github.event.inputs.domain_name }}
              secretName: dx02-tls-secret
            rules:
            - host: ${{ github.event.inputs.domain_name }}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: dx02-service
                      port:
                        number: 80
          EOF
          
          echo "âœ… Ingress updated with HTTPS for domain: ${{ github.event.inputs.domain_name }}"

      - name: ğŸ“Š Display final summary
        run: |
          echo "======================================"
          echo "ğŸ‰ Security Infrastructure Deployed!"
          echo "======================================"
          echo ""
          
          if [[ "${{ github.event.inputs.install_cert_manager }}" == "true" ]]; then
            echo "ğŸ“œ cert-manager: âœ… Installed"
            ISSUER_NAME="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'letsencrypt-prod' || 'letsencrypt-staging' }}"
            echo "   ClusterIssuer: $ISSUER_NAME"
            echo "   Email: ${{ github.event.inputs.letsencrypt_email }}"
            echo "   Domain: ${{ github.event.inputs.domain_name }}"
          fi
          
          if [[ "${{ github.event.inputs.deploy_app_gateway }}" == "true" ]]; then
            echo ""
            echo "ğŸ›¡ï¸ Application Gateway: âœ… Deployed & Configured"
            echo "   SKU: ${{ github.event.inputs.app_gateway_sku }}"
            echo "   WAF Mode: ${{ github.event.inputs.waf_mode }}"
            
            APPGW_IP=$(az network public-ip show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.APP_GATEWAY_NAME }}-pip \
              --query ipAddress -o tsv 2>/dev/null || echo "N/A")
            
            echo "   Public IP: $APPGW_IP"
            echo ""
            echo "âœ… Backend Pool: Configured with AKS node IPs"
            echo "âœ… Health Probes: HTTP and HTTPS configured"
            echo "âœ… SSL Certificate: Uploaded from cert-manager"
            echo "âœ… HTTPS Listener: Configured with Let's Encrypt certificate"
            echo "âœ… Routing Rules: HTTP (redirect) and HTTPS configured"
          fi
          
          echo ""
          echo "======================================"
          echo "ğŸ“ NEXT STEPS:"
          echo "======================================"
          echo ""
          
          if [[ "${{ github.event.inputs.deploy_app_gateway }}" == "true" ]]; then
            APPGW_IP=$(az network public-ip show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.APP_GATEWAY_NAME }}-pip \
              --query ipAddress -o tsv 2>/dev/null || echo "CHECK_AZURE_PORTAL")
            
            echo "1ï¸âƒ£ Update DNS at ddns.net:"
            echo "   Hostname: ${{ github.event.inputs.domain_name }}"
            echo "   Point to: $APPGW_IP"
            echo ""
            echo "2ï¸âƒ£ Wait 5-10 minutes for:"
            echo "   - DNS propagation"
            echo "   - Application Gateway health probes"
            echo "   - Certificate validation"
            echo ""
            echo "3ï¸âƒ£ Test your application:"
            echo "   ğŸ”— HTTP:  http://${{ github.event.inputs.domain_name }} (should redirect to HTTPS)"
            echo "   ğŸ”’ HTTPS: https://${{ github.event.inputs.domain_name }} (should return 200 OK)"
            echo ""
            echo "4ï¸âƒ£ Verify WAF is active:"
            echo "   Check Azure Portal â†’ Application Gateway â†’ Web Application Firewall"
          else
            echo "1ï¸âƒ£ Go to ddns.net"
            echo "2ï¸âƒ£ Create/Update hostname: ${{ github.event.inputs.domain_name }}"
            echo "3ï¸âƒ£ Point to Nginx Ingress IP"
            echo ""
            echo "4ï¸âƒ£ Wait 5-10 minutes for cert-manager to issue certificate"
            echo "5ï¸âƒ£ Access: https://${{ github.event.inputs.domain_name }}"
          fi
          
          echo ""
          echo "âœ… Deployment complete!"
          echo ""
          echo "ğŸ“š Documentation:"
          echo "   - APPLICATION_GATEWAY_MANUAL_STEPS.md"
          echo "   - SECURITY_INFRASTRUCTURE.md"
          echo "   - WORKFLOW_UPDATE_CHECKLIST.md"

