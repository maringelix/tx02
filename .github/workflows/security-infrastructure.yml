name: ğŸ›¡ï¸ Deploy Security Infrastructure (cert-manager + WAF)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - prd
          - stg
        default: prd
      install_cert_manager:
        description: 'Install cert-manager for automatic HTTPS'
        required: true
        type: boolean
        default: true
      letsencrypt_email:
        description: 'Email for Let''s Encrypt notifications'
        required: true
        default: 'admin@example.com'
      domain_name:
        description: 'Domain name for HTTPS certificate (e.g., dx02.no-ip.org)'
        required: true
        default: 'dx02.example.com'
      use_letsencrypt_prod:
        description: 'Use Let''s Encrypt Production (false = staging)'
        required: true
        type: boolean
        default: false
      deploy_app_gateway:
        description: 'Deploy Azure Application Gateway with WAF'
        required: true
        type: boolean
        default: false
      app_gateway_sku:
        description: 'Application Gateway SKU'
        required: true
        type: choice
        options:
          - WAF_v2
          - Standard_v2
        default: WAF_v2
      waf_mode:
        description: 'WAF Mode'
        required: true
        type: choice
        options:
          - Prevention
          - Detection
        default: Detection

permissions:
  contents: read
  id-token: write

env:
  AZURE_RESOURCE_GROUP: tx02-${{ github.event.inputs.environment }}-rg
  AKS_CLUSTER_NAME: tx02-${{ github.event.inputs.environment }}-aks
  LOCATION: eastus
  APP_GATEWAY_NAME: tx02-${{ github.event.inputs.environment }}-appgw
  VNET_NAME: tx02-${{ github.event.inputs.environment }}-vnet
  APP_GATEWAY_SUBNET: tx02-${{ github.event.inputs.environment }}-subnet-appgw

jobs:
  deploy-cert-manager:
    name: ğŸ“œ Deploy cert-manager
    runs-on: ubuntu-latest
    if: github.event.inputs.install_cert_manager == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ” Check if cert-manager is already installed
        id: check-cert-manager
        continue-on-error: true
        run: |
          if kubectl get namespace cert-manager &> /dev/null; then
            echo "installed=true" >> $GITHUB_OUTPUT
            echo "âœ… cert-manager jÃ¡ estÃ¡ instalado"
          else
            echo "installed=false" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ cert-manager nÃ£o estÃ¡ instalado"
          fi

      - name: ğŸ“¦ Install cert-manager using Helm
        if: steps.check-cert-manager.outputs.installed == 'false'
        run: |
          echo "ğŸ“¦ Installing cert-manager..."
          
          # Add Jetstack Helm repository
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          
          # Install cert-manager with CRDs
          helm install cert-manager jetstack/cert-manager \
            --namespace cert-manager \
            --create-namespace \
            --version v1.14.0 \
            --set installCRDs=true \
            --set global.leaderElection.namespace=cert-manager \
            --wait --timeout=5m
          
          echo "âœ… cert-manager installed successfully"

      - name: â³ Wait for cert-manager to be ready
        run: |
          echo "â³ Waiting for cert-manager pods to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=300s
          echo "âœ… cert-manager is ready"

      - name: ğŸ”‘ Create ClusterIssuer for Let's Encrypt
        run: |
          LETSENCRYPT_SERVER="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'https://acme-v02.api.letsencrypt.org/directory' || 'https://acme-staging-v02.api.letsencrypt.org/directory' }}"
          ISSUER_NAME="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'letsencrypt-prod' || 'letsencrypt-staging' }}"
          
          echo "ğŸ”‘ Creating ClusterIssuer: $ISSUER_NAME"
          echo "ğŸ“§ Email: ${{ github.event.inputs.letsencrypt_email }}"
          echo "ğŸŒ Server: $LETSENCRYPT_SERVER"
          
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: $ISSUER_NAME
          spec:
            acme:
              server: $LETSENCRYPT_SERVER
              email: ${{ github.event.inputs.letsencrypt_email }}
              privateKeySecretRef:
                name: $ISSUER_NAME-account-key
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF
          
          echo "âœ… ClusterIssuer created: $ISSUER_NAME"

      - name: ğŸ« Create sample certificate for testing
        run: |
          ISSUER_NAME="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'letsencrypt-prod' || 'letsencrypt-staging' }}"
          
          echo "ğŸ« Creating test certificate in dx02 namespace..."
          
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: Certificate
          metadata:
            name: dx02-tls-cert
            namespace: dx02
          spec:
            secretName: dx02-tls-secret
            issuerRef:
              name: $ISSUER_NAME
              kind: ClusterIssuer
            dnsNames:
            - ${{ github.event.inputs.domain_name }}
          EOF
          
          echo "âœ… Certificate created for domain: ${{ github.event.inputs.domain_name }}"
          echo "âš ï¸  Make sure DNS points to: 48.194.53.219"

      - name: ğŸ“Š Verify cert-manager installation
        run: |
          echo "======================================"
          echo "ğŸ“œ cert-manager Installation Summary"
          echo "======================================"
          echo ""
          
          echo "ğŸ“¦ cert-manager Pods:"
          kubectl get pods -n cert-manager
          echo ""
          
          echo "ğŸ”‘ ClusterIssuers:"
          kubectl get clusterissuer
          echo ""
          
          echo "ğŸ« Certificates:"
          kubectl get certificate --all-namespaces
          echo ""
          
          echo "âœ… cert-manager is ready to issue certificates!"

  deploy-application-gateway:
    name: ğŸ›¡ï¸ Deploy Application Gateway with WAF
    runs-on: ubuntu-latest
    if: github.event.inputs.deploy_app_gateway == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ” Check if Application Gateway exists
        id: check-appgw
        continue-on-error: true
        run: |
          if az network application-gateway show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Application Gateway jÃ¡ existe"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ Application Gateway nÃ£o existe"
          fi

      - name: ğŸŒ Verify subnet for Application Gateway
        if: steps.check-appgw.outputs.exists == 'false'
        run: |
          echo "ğŸŒ Verifying subnet for Application Gateway..."
          
          # Check if subnet already exists
          if az network vnet subnet show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --vnet-name ${{ env.VNET_NAME }} \
            --name ${{ env.APP_GATEWAY_SUBNET }} &> /dev/null; then
            echo "âœ… Subnet '${{ env.APP_GATEWAY_SUBNET }}' already exists"
            
            SUBNET_PREFIX=$(az network vnet subnet show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --vnet-name ${{ env.VNET_NAME }} \
              --name ${{ env.APP_GATEWAY_SUBNET }} \
              --query addressPrefix -o tsv)
            echo "   Address prefix: $SUBNET_PREFIX"
          else
            echo "âŒ Subnet does not exist. Creating with address prefix 10.0.5.0/24..."
            az network vnet subnet create \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --vnet-name ${{ env.VNET_NAME }} \
              --name ${{ env.APP_GATEWAY_SUBNET }} \
              --address-prefixes 10.0.5.0/24
            
            echo "âœ… Subnet created"
          fi

      - name: ğŸŒ Create Public IP for Application Gateway
        id: get-ip
        if: steps.check-appgw.outputs.exists == 'false'
        run: |
          echo "ğŸŒ Creating Public IP for Application Gateway..."
          
          # Create new Public IP for Application Gateway
          az network public-ip create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-pip \
            --location ${{ env.LOCATION }} \
            --allocation-method Static \
            --sku Standard \
            --tags Environment=${{ github.event.inputs.environment }} ManagedBy=GitHub-Actions
          
          IP_ADDRESS=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-pip \
            --query ipAddress -o tsv)
          
          echo "ip_address=$IP_ADDRESS" >> $GITHUB_OUTPUT
          echo "ip_name=${{ env.APP_GATEWAY_NAME }}-pip" >> $GITHUB_OUTPUT
          
          echo "âœ… Public IP created:"
          echo "   Name: ${{ env.APP_GATEWAY_NAME }}-pip"
          echo "   IP: $IP_ADDRESS"
          echo ""
          echo "âš ï¸  IMPORTANTE: Atualize seu DNS dx02.ddns.net para este novo IP: $IP_ADDRESS"

      - name: ğŸ›¡ï¸ Create WAF Policy (before Application Gateway)
        if: steps.check-appgw.outputs.exists == 'false' && github.event.inputs.app_gateway_sku == 'WAF_v2'
        run: |
          echo "ğŸ›¡ï¸ Creating WAF policy..."
          
          # Create WAF policy
          az network application-gateway waf-policy create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --location ${{ env.LOCATION }}
          
          # Configure WAF settings
          az network application-gateway waf-policy policy-setting update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --policy-name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --mode ${{ github.event.inputs.waf_mode }} \
            --state Enabled \
            --max-request-body-size-in-kb 128 \
            --file-upload-limit-in-mb 100
          
          echo "âœ… WAF policy created"

      - name: ğŸ›¡ï¸ Create Application Gateway with WAF
        if: steps.check-appgw.outputs.exists == 'false'
        run: |
          echo "ğŸ›¡ï¸ Creating Application Gateway with WAF..."
          echo "SKU: ${{ github.event.inputs.app_gateway_sku }}"
          echo "WAF Mode: ${{ github.event.inputs.waf_mode }}"
          
          # Get subnet ID
          SUBNET_ID=$(az network vnet subnet show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --vnet-name ${{ env.VNET_NAME }} \
            --name ${{ env.APP_GATEWAY_SUBNET }} \
            --query id -o tsv)
          
          # Use Public IP created in previous step
          echo "ğŸ”— Using Public IP: ${{ steps.get-ip.outputs.ip_address }}"
          PUBLIC_IP_NAME="${{ steps.get-ip.outputs.ip_name }}"
          
          # Get Public IP ID
          PUBLIC_IP_ID=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name $PUBLIC_IP_NAME \
            --query id -o tsv)
          
          # Get WAF Policy ID if SKU is WAF_v2
          if [ "${{ github.event.inputs.app_gateway_sku }}" == "WAF_v2" ]; then
            WAF_POLICY_ID=$(az network application-gateway waf-policy show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
              --query id -o tsv)
            echo "ğŸ›¡ï¸ Using WAF Policy: $WAF_POLICY_ID"
            WAF_POLICY_ARG="--waf-policy $WAF_POLICY_ID"
          else
            WAF_POLICY_ARG=""
          fi
          
          # Create Application Gateway
          az network application-gateway create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --location ${{ env.LOCATION }} \
            --sku ${{ github.event.inputs.app_gateway_sku }} \
            --capacity 2 \
            --vnet-name ${{ env.VNET_NAME }} \
            --subnet $SUBNET_ID \
            --public-ip-address $PUBLIC_IP_ID \
            --http-settings-cookie-based-affinity Disabled \
            --frontend-port 80 \
            --http-settings-port 80 \
            --http-settings-protocol Http \
            --priority 100 \
            $WAF_POLICY_ARG \
            --tags Environment=${{ github.event.inputs.environment }} ManagedBy=GitHub-Actions
          
          echo "âœ… Application Gateway created"

      - name: ğŸ›¡ï¸ Verify WAF Policy association
        if: github.event.inputs.app_gateway_sku == 'WAF_v2'
        run: |
          echo "ğŸ›¡ï¸ Configuring WAF policy..."
          
          # Create WAF policy
          az network application-gateway waf-policy create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --location ${{ env.LOCATION }}
          
          # Configure WAF settings
          az network application-gateway waf-policy policy-setting update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --policy-name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --mode ${{ github.event.inputs.waf_mode }} \
            --state Enabled \
            --max-request-body-size-in-kb 128 \
            --file-upload-limit-in-mb 100
          
          # Associate WAF policy with Application Gateway
          az network application-gateway update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --set firewallPolicy.id=$(az network application-gateway waf-policy show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
              --query id -o tsv)
          
          echo "âœ… WAF policy configured"

      - name: ğŸ”§ Install AGIC (Application Gateway Ingress Controller)
        run: |
          echo "ğŸ”§ Installing AGIC..."
          
          # Enable AGIC add-on on AKS
          az aks enable-addons \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --addons ingress-appgw \
            --appgw-id $(az network application-gateway show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.APP_GATEWAY_NAME }} \
              --query id -o tsv) || echo "âš ï¸ AGIC may already be enabled"
          
          echo "âœ… AGIC configured"

      - name: ğŸ“Š Verify Application Gateway installation
        run: |
          echo "======================================"
          echo "ğŸ›¡ï¸ Application Gateway Summary"
          echo "======================================"
          echo ""
          
          echo "ğŸŒ Application Gateway:"
          az network application-gateway show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --query "{name:name,sku:sku.name,tier:sku.tier,capacity:sku.capacity,provisioningState:provisioningState}" \
            -o table
          echo ""
          
          echo "ğŸŒ Public IP (novo):"
          APPGW_IP=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-pip \
            --query ipAddress -o tsv)
          echo "IP Address: $APPGW_IP"
          echo ""
          echo "âš ï¸  IMPORTANTE: Atualize seu DNS!"
          echo "   dx02.ddns.net â†’ $APPGW_IP"
          echo ""
          
          echo "ğŸ›¡ï¸ WAF Policy:"
          az network application-gateway waf-policy show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --query "{name:name,mode:policySettings.mode,state:policySettings.state}" \
            -o table 2>/dev/null || echo "WAF policy not configured"
          echo ""
          
          echo "âœ… Application Gateway is ready!"

  configure-backend-pool:
    name: ğŸ”§ Configure Application Gateway Backend
    runs-on: ubuntu-latest
    needs: deploy-application-gateway
    if: |
      always() && 
      github.event.inputs.deploy_app_gateway == 'true' &&
      needs.deploy-application-gateway.result == 'success'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ” Get AKS Node IPs
        id: get-nodes
        run: |
          echo "ğŸ” Getting AKS node internal IPs..."
          NODE_IPS=$(kubectl get nodes -o jsonpath='{.items[*].status.addresses[?(@.type=="InternalIP")].address}' | tr ' ' ' ')
          echo "node_ips=$NODE_IPS" >> $GITHUB_OUTPUT
          echo "âœ… Node IPs: $NODE_IPS"

      - name: ğŸ” Get Nginx Ingress NodePorts
        id: get-nodeports
        run: |
          echo "ğŸ” Getting Nginx Ingress NodePorts..."
          HTTP_NODEPORT=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.spec.ports[?(@.port==80)].nodePort}')
          HTTPS_NODEPORT=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.spec.ports[?(@.port==443)].nodePort}')
          
          echo "http_nodeport=$HTTP_NODEPORT" >> $GITHUB_OUTPUT
          echo "https_nodeport=$HTTPS_NODEPORT" >> $GITHUB_OUTPUT
          
          echo "âœ… HTTP NodePort: $HTTP_NODEPORT"
          echo "âœ… HTTPS NodePort: $HTTPS_NODEPORT"

      - name: ğŸ”§ Update Backend Pool with Node IPs
        run: |
          echo "ğŸ”§ Updating Application Gateway backend pool..."
          az network application-gateway address-pool update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name appGatewayBackendPool \
            --servers ${{ steps.get-nodes.outputs.node_ips }}
          
          echo "âœ… Backend pool updated with node IPs"

      - name: ğŸ”§ Update HTTP Settings for HTTP (NodePort)
        run: |
          echo "ğŸ”§ Updating HTTP settings for NodePort ${{ steps.get-nodeports.outputs.http_nodeport }}..."
          az network application-gateway http-settings update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name appGatewayBackendHttpSettings \
            --port ${{ steps.get-nodeports.outputs.http_nodeport }} \
            --protocol Http \
            --timeout 30
          
          echo "âœ… HTTP settings updated"

      - name: ğŸ¥ Create Health Probe HTTP with Hostname
        run: |
          echo "ğŸ¥ Creating HTTP health probe..."
          az network application-gateway probe create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name dx02-health-probe \
            --protocol Http \
            --host ${{ github.event.inputs.domain_name }} \
            --path / \
            --interval 30 \
            --timeout 30 \
            --threshold 3 \
            || echo "âš ï¸ Health probe may already exist"
          
          echo "âœ… Health probe created"

      - name: ğŸ”— Associate Health Probe to HTTP Settings
        run: |
          echo "ğŸ”— Associating health probe to HTTP settings..."
          az network application-gateway http-settings update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name appGatewayBackendHttpSettings \
            --probe dx02-health-probe
          
          echo "âœ… Health probe associated"

      - name: â³ Wait for Backend Health Check
        run: |
          echo "â³ Waiting 60 seconds for backend health probes..."
          sleep 60

      - name: ğŸ¥ Verify Backend Health
        run: |
          echo "ğŸ¥ Checking backend health..."
          az network application-gateway show-backend-health \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --query 'backendAddressPools[0].backendHttpSettingsCollection[0].servers[*].{address:address, health:health}' \
            -o table
          
          echo "âœ… Backend health check complete"

  configure-ssl-certificate:
    name: ğŸ” Configure SSL Certificate
    runs-on: ubuntu-latest
    needs: [deploy-cert-manager, configure-backend-pool]
    if: |
      always() && 
      github.event.inputs.install_cert_manager == 'true' &&
      github.event.inputs.deploy_app_gateway == 'true' &&
      needs.deploy-cert-manager.result == 'success' &&
      needs.configure-backend-pool.result == 'success'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: â³ Wait for Certificate to be Ready
        run: |
          echo "â³ Waiting for certificate to be issued..."
          kubectl wait --for=condition=Ready certificate/dx02-tls \
            -n dx02 \
            --timeout=600s || echo "âš ï¸ Certificate may not be ready yet"
          
          echo "âœ… Checking certificate status..."
          kubectl get certificate -n dx02

      - name: ğŸ“œ Export Certificate from Kubernetes
        run: |
          echo "ğŸ“œ Exporting certificate from Kubernetes secret..."
          kubectl get secret dx02-tls -n dx02 \
            -o jsonpath='{.data.tls\.crt}' | base64 -d > tls.crt
          kubectl get secret dx02-tls -n dx02 \
            -o jsonpath='{.data.tls\.key}' | base64 -d > tls.key
          
          echo "âœ… Certificate exported"
          ls -lh tls.crt tls.key

      - name: ğŸ” Convert Certificate to PFX
        run: |
          echo "ğŸ” Converting certificate to PFX format..."
          openssl pkcs12 -export \
            -out dx02-tls.pfx \
            -inkey tls.key \
            -in tls.crt \
            -passout pass:${{ secrets.CERT_PASSWORD }}
          
          echo "âœ… Certificate converted to PFX"
          ls -lh dx02-tls.pfx

      - name: ğŸ“¤ Upload Certificate to Application Gateway
        run: |
          echo "ğŸ“¤ Uploading SSL certificate to Application Gateway..."
          az network application-gateway ssl-cert create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name dx02-ssl-cert \
            --cert-file dx02-tls.pfx \
            --cert-password "${{ secrets.CERT_PASSWORD }}" \
            || az network application-gateway ssl-cert update \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --gateway-name ${{ env.APP_GATEWAY_NAME }} \
              --name dx02-ssl-cert \
              --cert-file dx02-tls.pfx \
              --cert-password "${{ secrets.CERT_PASSWORD }}"
          
          echo "âœ… SSL certificate uploaded"

      - name: ğŸ§¹ Cleanup temporary files
        if: always()
        run: |
          rm -f tls.crt tls.key dx02-tls.pfx
          echo "âœ… Temporary certificate files removed"

  configure-https-listener:
    name: ğŸ”Š Configure HTTPS Listener & Routing
    runs-on: ubuntu-latest
    needs: [configure-backend-pool, configure-ssl-certificate]
    if: |
      always() && 
      github.event.inputs.deploy_app_gateway == 'true' &&
      needs.configure-backend-pool.result == 'success' &&
      needs.configure-ssl-certificate.result == 'success'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ” Get HTTPS NodePort
        id: get-https-nodeport
        run: |
          HTTPS_NODEPORT=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.spec.ports[?(@.port==443)].nodePort}')
          echo "https_nodeport=$HTTPS_NODEPORT" >> $GITHUB_OUTPUT
          echo "âœ… HTTPS NodePort: $HTTPS_NODEPORT"

      - name: ğŸ”Œ Create Frontend Port 443
        run: |
          echo "ğŸ”Œ Creating frontend port 443..."
          az network application-gateway frontend-port create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name port443 \
            --port 443 \
            || echo "âš ï¸ Port 443 may already exist"
          
          echo "âœ… Frontend port 443 ready"

      - name: ğŸ”Š Create HTTPS Listener
        run: |
          echo "ğŸ”Š Creating HTTPS listener..."
          az network application-gateway http-listener create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name httpsListener \
            --frontend-port port443 \
            --frontend-ip appGatewayFrontendIP \
            --ssl-cert dx02-ssl-cert \
            --host-name ${{ github.event.inputs.domain_name }} \
            || echo "âš ï¸ HTTPS listener may already exist"
          
          echo "âœ… HTTPS listener created"

      - name: ğŸ¥ Create HTTPS Health Probe
        run: |
          echo "ğŸ¥ Creating HTTPS health probe..."
          az network application-gateway probe create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name dx02-https-probe \
            --protocol Https \
            --host ${{ github.event.inputs.domain_name }} \
            --path / \
            --interval 30 \
            --timeout 30 \
            --threshold 3 \
            || echo "âš ï¸ HTTPS health probe may already exist"
          
          echo "âœ… HTTPS health probe created"

      - name: ğŸ”§ Create HTTPS Backend Settings
        run: |
          echo "ğŸ”§ Creating HTTPS backend settings..."
          az network application-gateway http-settings create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name httpsBackendSettings \
            --port ${{ steps.get-https-nodeport.outputs.https_nodeport }} \
            --protocol Https \
            --timeout 30 \
            --probe dx02-https-probe \
            || echo "âš ï¸ HTTPS backend settings may already exist"
          
          echo "âœ… HTTPS backend settings created"

      - name: ğŸ”€ Create HTTPS Routing Rule
        run: |
          echo "ğŸ”€ Creating HTTPS routing rule..."
          az network application-gateway rule create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --name httpsRule \
            --http-listener httpsListener \
            --address-pool appGatewayBackendPool \
            --http-settings httpsBackendSettings \
            --priority 200 \
            || echo "âš ï¸ HTTPS routing rule may already exist"
          
          echo "âœ… HTTPS routing rule created"

  validate-deployment:
    name: âœ… Validate Application Gateway Deployment
    runs-on: ubuntu-latest
    needs: [configure-backend-pool, configure-https-listener]
    if: |
      always() && 
      github.event.inputs.deploy_app_gateway == 'true' &&
      needs.configure-backend-pool.result == 'success' &&
      needs.configure-https-listener.result == 'success'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: â³ Wait for Configuration to Settle
        run: |
          echo "â³ Waiting 90 seconds for Application Gateway to process all changes..."
          sleep 90

      - name: ğŸ¥ Final Backend Health Check
        run: |
          echo "ğŸ¥ Checking final backend health status..."
          az network application-gateway show-backend-health \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --query 'backendAddressPools[0].backendHttpSettingsCollection[*].servers[*].{address:address, health:health, httpSettings:backendHttpSettings.id}' \
            -o table

      - name: ğŸ“Š Display Application Gateway Summary
        run: |
          echo "======================================"
          echo "ğŸ›¡ï¸ Application Gateway Configuration"
          echo "======================================"
          echo ""
          
          echo "ğŸ“‹ Backend Pools:"
          az network application-gateway address-pool list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            -o table
          echo ""
          
          echo "ğŸ”Š HTTP Listeners:"
          az network application-gateway http-listener list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --query '[].{Name:name, Protocol:protocol, Port:frontendPort.id, Hostname:hostName}' \
            -o table
          echo ""
          
          echo "ğŸ”€ Routing Rules:"
          az network application-gateway rule list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --gateway-name ${{ env.APP_GATEWAY_NAME }} \
            --query '[].{Name:name, Priority:priority, Listener:httpListener.id}' \
            -o table
          echo ""
          
          APPGW_IP=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-pip \
            --query ipAddress -o tsv)
          
          echo "======================================"
          echo "âœ… Application Gateway Ready!"
          echo "======================================"
          echo ""
          echo "ğŸŒ Public IP: $APPGW_IP"
          echo "ğŸ”— Test HTTP:  http://${{ github.event.inputs.domain_name }}"
          echo "ğŸ”’ Test HTTPS: https://${{ github.event.inputs.domain_name }}"
          echo ""
          echo "âš ï¸  IMPORTANTE: Certifique-se de que o DNS estÃ¡ configurado!"
          echo "   ${{ github.event.inputs.domain_name }} â†’ $APPGW_IP"

  configure-ingress:
    name: ğŸ”— Configure Ingress with HTTPS
    runs-on: ubuntu-latest
    needs: [deploy-cert-manager, deploy-application-gateway, validate-deployment]
    if: |
      always() && 
      (needs.deploy-cert-manager.result == 'success' || needs.deploy-cert-manager.result == 'skipped') &&
      (needs.deploy-application-gateway.result == 'success' || needs.deploy-application-gateway.result == 'skipped') &&
      (needs.validate-deployment.result == 'success' || needs.validate-deployment.result == 'skipped')
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ”— Update DX02 Ingress with HTTPS and cert-manager
        if: github.event.inputs.install_cert_manager == 'true'
        run: |
          ISSUER_NAME="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'letsencrypt-prod' || 'letsencrypt-staging' }}"
          
          echo "ğŸ”— Updating DX02 Ingress with HTTPS support..."
          echo "Domain: ${{ github.event.inputs.domain_name }}"
          
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: dx02
            namespace: dx02
            annotations:
              cert-manager.io/cluster-issuer: $ISSUER_NAME
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
              nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
              nginx.ingress.kubernetes.io/proxy-body-size: "10m"
              nginx.ingress.kubernetes.io/rate-limit: "100"
          spec:
            ingressClassName: nginx
            tls:
            - hosts:
              - ${{ github.event.inputs.domain_name }}
              secretName: dx02-tls-secret
            rules:
            - host: ${{ github.event.inputs.domain_name }}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: dx02-service
                      port:
                        number: 80
          EOF
          
          echo "âœ… Ingress updated with HTTPS for domain: ${{ github.event.inputs.domain_name }}"

      - name: ğŸ“Š Display final summary
        run: |
          echo "======================================"
          echo "ğŸ‰ Security Infrastructure Deployed!"
          echo "======================================"
          echo ""
          
          if [[ "${{ github.event.inputs.install_cert_manager }}" == "true" ]]; then
            echo "ğŸ“œ cert-manager: âœ… Installed"
            ISSUER_NAME="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'letsencrypt-prod' || 'letsencrypt-staging' }}"
            echo "   ClusterIssuer: $ISSUER_NAME"
            echo "   Email: ${{ github.event.inputs.letsencrypt_email }}"
            echo "   Domain: ${{ github.event.inputs.domain_name }}"
          fi
          
          if [[ "${{ github.event.inputs.deploy_app_gateway }}" == "true" ]]; then
            echo ""
            echo "ğŸ›¡ï¸ Application Gateway: âœ… Deployed & Configured"
            echo "   SKU: ${{ github.event.inputs.app_gateway_sku }}"
            echo "   WAF Mode: ${{ github.event.inputs.waf_mode }}"
            
            APPGW_IP=$(az network public-ip show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.APP_GATEWAY_NAME }}-pip \
              --query ipAddress -o tsv 2>/dev/null || echo "N/A")
            
            echo "   Public IP: $APPGW_IP"
            echo ""
            echo "âœ… Backend Pool: Configured with AKS node IPs"
            echo "âœ… Health Probes: HTTP and HTTPS configured"
            echo "âœ… SSL Certificate: Uploaded from cert-manager"
            echo "âœ… HTTPS Listener: Configured with Let's Encrypt certificate"
            echo "âœ… Routing Rules: HTTP (redirect) and HTTPS configured"
          fi
          
          echo ""
          echo "======================================"
          echo "ğŸ“ NEXT STEPS:"
          echo "======================================"
          echo ""
          
          if [[ "${{ github.event.inputs.deploy_app_gateway }}" == "true" ]]; then
            APPGW_IP=$(az network public-ip show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.APP_GATEWAY_NAME }}-pip \
              --query ipAddress -o tsv 2>/dev/null || echo "CHECK_AZURE_PORTAL")
            
            echo "1ï¸âƒ£ Update DNS at ddns.net:"
            echo "   Hostname: ${{ github.event.inputs.domain_name }}"
            echo "   Point to: $APPGW_IP"
            echo ""
            echo "2ï¸âƒ£ Wait 5-10 minutes for:"
            echo "   - DNS propagation"
            echo "   - Application Gateway health probes"
            echo "   - Certificate validation"
            echo ""
            echo "3ï¸âƒ£ Test your application:"
            echo "   ğŸ”— HTTP:  http://${{ github.event.inputs.domain_name }} (should redirect to HTTPS)"
            echo "   ğŸ”’ HTTPS: https://${{ github.event.inputs.domain_name }} (should return 200 OK)"
            echo ""
            echo "4ï¸âƒ£ Verify WAF is active:"
            echo "   Check Azure Portal â†’ Application Gateway â†’ Web Application Firewall"
          else
            echo "1ï¸âƒ£ Go to ddns.net"
            echo "2ï¸âƒ£ Create/Update hostname: ${{ github.event.inputs.domain_name }}"
            echo "3ï¸âƒ£ Point to Nginx Ingress IP"
            echo ""
            echo "4ï¸âƒ£ Wait 5-10 minutes for cert-manager to issue certificate"
            echo "5ï¸âƒ£ Access: https://${{ github.event.inputs.domain_name }}"
          fi
          
          echo ""
          echo "âœ… Deployment complete!"
          echo ""
          echo "ğŸ“š Documentation:"
          echo "   - APPLICATION_GATEWAY_MANUAL_STEPS.md"
          echo "   - SECURITY_INFRASTRUCTURE.md"
          echo "   - WORKFLOW_UPDATE_CHECKLIST.md"

