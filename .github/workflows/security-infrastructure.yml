name: ğŸ›¡ï¸ Deploy Security Infrastructure (cert-manager + WAF)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - prd
          - stg
        default: prd
      install_cert_manager:
        description: 'Install cert-manager for automatic HTTPS'
        required: true
        type: boolean
        default: true
      letsencrypt_email:
        description: 'Email for Let''s Encrypt notifications'
        required: true
        default: 'admin@example.com'
      domain_name:
        description: 'Domain name for HTTPS certificate (e.g., dx02.no-ip.org)'
        required: true
        default: 'dx02.example.com'
      use_letsencrypt_prod:
        description: 'Use Let''s Encrypt Production (false = staging)'
        required: true
        type: boolean
        default: false
      deploy_app_gateway:
        description: 'Deploy Azure Application Gateway with WAF'
        required: true
        type: boolean
        default: true
      app_gateway_sku:
        description: 'Application Gateway SKU'
        required: true
        type: choice
        options:
          - WAF_v2
          - Standard_v2
        default: WAF_v2
      waf_mode:
        description: 'WAF Mode'
        required: true
        type: choice
        options:
          - Prevention
          - Detection
        default: Detection

permissions:
  contents: read
  id-token: write

env:
  AZURE_RESOURCE_GROUP: tx02-${{ github.event.inputs.environment }}-rg
  AKS_CLUSTER_NAME: tx02-${{ github.event.inputs.environment }}-aks
  LOCATION: eastus
  APP_GATEWAY_NAME: tx02-${{ github.event.inputs.environment }}-appgw
  VNET_NAME: tx02-${{ github.event.inputs.environment }}-vnet
  APP_GATEWAY_SUBNET: appgw-subnet

jobs:
  deploy-cert-manager:
    name: ğŸ“œ Deploy cert-manager
    runs-on: ubuntu-latest
    if: github.event.inputs.install_cert_manager == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ” Check if cert-manager is already installed
        id: check-cert-manager
        continue-on-error: true
        run: |
          if kubectl get namespace cert-manager &> /dev/null; then
            echo "installed=true" >> $GITHUB_OUTPUT
            echo "âœ… cert-manager jÃ¡ estÃ¡ instalado"
          else
            echo "installed=false" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ cert-manager nÃ£o estÃ¡ instalado"
          fi

      - name: ğŸ“¦ Install cert-manager using Helm
        if: steps.check-cert-manager.outputs.installed == 'false'
        run: |
          echo "ğŸ“¦ Installing cert-manager..."
          
          # Add Jetstack Helm repository
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          
          # Install cert-manager with CRDs
          helm install cert-manager jetstack/cert-manager \
            --namespace cert-manager \
            --create-namespace \
            --version v1.14.0 \
            --set installCRDs=true \
            --set global.leaderElection.namespace=cert-manager \
            --wait --timeout=5m
          
          echo "âœ… cert-manager installed successfully"

      - name: â³ Wait for cert-manager to be ready
        run: |
          echo "â³ Waiting for cert-manager pods to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=300s
          echo "âœ… cert-manager is ready"

      - name: ğŸ”‘ Create ClusterIssuer for Let's Encrypt
        run: |
          LETSENCRYPT_SERVER="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'https://acme-v02.api.letsencrypt.org/directory' || 'https://acme-staging-v02.api.letsencrypt.org/directory' }}"
          ISSUER_NAME="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'letsencrypt-prod' || 'letsencrypt-staging' }}"
          
          echo "ğŸ”‘ Creating ClusterIssuer: $ISSUER_NAME"
          echo "ğŸ“§ Email: ${{ github.event.inputs.letsencrypt_email }}"
          echo "ğŸŒ Server: $LETSENCRYPT_SERVER"
          
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: $ISSUER_NAME
          spec:
            acme:
              server: $LETSENCRYPT_SERVER
              email: ${{ github.event.inputs.letsencrypt_email }}
              privateKeySecretRef:
                name: $ISSUER_NAME-account-key
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF
          
          echo "âœ… ClusterIssuer created: $ISSUER_NAME"

      - name: ğŸ« Create sample certificate for testing
        run: |
          ISSUER_NAME="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'letsencrypt-prod' || 'letsencrypt-staging' }}"
          
          echo "ğŸ« Creating test certificate in dx02 namespace..."
          
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: Certificate
          metadata:
            name: dx02-tls-cert
            namespace: dx02
          spec:
            secretName: dx02-tls-secret
            issuerRef:
              name: $ISSUER_NAME
              kind: ClusterIssuer
            dnsNames:
            - ${{ github.event.inputs.domain_name }}
          EOF
          
          echo "âœ… Certificate created for domain: ${{ github.event.inputs.domain_name }}"
          echo "âš ï¸  Make sure DNS points to: 48.194.53.219"

      - name: ğŸ“Š Verify cert-manager installation
        run: |
          echo "======================================"
          echo "ğŸ“œ cert-manager Installation Summary"
          echo "======================================"
          echo ""
          
          echo "ğŸ“¦ cert-manager Pods:"
          kubectl get pods -n cert-manager
          echo ""
          
          echo "ğŸ”‘ ClusterIssuers:"
          kubectl get clusterissuer
          echo ""
          
          echo "ğŸ« Certificates:"
          kubectl get certificate --all-namespaces
          echo ""
          
          echo "âœ… cert-manager is ready to issue certificates!"

  deploy-application-gateway:
    name: ğŸ›¡ï¸ Deploy Application Gateway with WAF
    runs-on: ubuntu-latest
    if: github.event.inputs.deploy_app_gateway == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ” Check if Application Gateway exists
        id: check-appgw
        continue-on-error: true
        run: |
          if az network application-gateway show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} &> /dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Application Gateway jÃ¡ existe"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ Application Gateway nÃ£o existe"
          fi

      - name: ğŸŒ Create subnet for Application Gateway
        if: steps.check-appgw.outputs.exists == 'false'
        run: |
          echo "ğŸŒ Creating subnet for Application Gateway..."
          
          # Check if subnet already exists
          if az network vnet subnet show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --vnet-name ${{ env.VNET_NAME }} \
            --name ${{ env.APP_GATEWAY_SUBNET }} &> /dev/null; then
            echo "âœ… Subnet already exists"
          else
            az network vnet subnet create \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --vnet-name ${{ env.VNET_NAME }} \
              --name ${{ env.APP_GATEWAY_SUBNET }} \
              --address-prefixes 10.1.0.0/24
            
            echo "âœ… Subnet created"
          fi

      - name: ğŸŒ Get existing Public IP from AKS
        id: get-ip
        run: |
          echo "ğŸ” Locating existing AKS Public IP..."
          
          # Get the Public IP used by AKS Load Balancer
          AKS_IP_ID=$(az aks show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --query "networkProfile.loadBalancerProfile.effectiveOutboundIPs[0].id" -o tsv)
          
          # Get IP details
          IP_ADDRESS=$(az network public-ip show --ids $AKS_IP_ID --query ipAddress -o tsv)
          IP_NAME=$(az network public-ip show --ids $AKS_IP_ID --query name -o tsv)
          IP_RG=$(az network public-ip show --ids $AKS_IP_ID --query resourceGroup -o tsv)
          
          echo "ip_address=$IP_ADDRESS" >> $GITHUB_OUTPUT
          echo "ip_name=$IP_NAME" >> $GITHUB_OUTPUT
          echo "ip_resource_group=$IP_RG" >> $GITHUB_OUTPUT
          
          echo "âœ… Found existing Public IP:"
          echo "   Name: $IP_NAME"
          echo "   IP: $IP_ADDRESS"
          echo "   Resource Group: $IP_RG"
          echo ""
          echo "âš ï¸  Configure your DNS to point to: $IP_ADDRESS"

      - name: ğŸ›¡ï¸ Create Application Gateway with WAF
        if: steps.check-appgw.outputs.exists == 'false'
        run: |
          echo "ğŸ›¡ï¸ Creating Application Gateway with WAF..."
          echo "SKU: ${{ github.event.inputs.app_gateway_sku }}"
          echo "WAF Mode: ${{ github.event.inputs.waf_mode }}"
          
          # Get subnet ID
          SUBNET_ID=$(az network vnet subnet show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --vnet-name ${{ env.VNET_NAME }} \
            --name ${{ env.APP_GATEWAY_SUBNET }} \
            --query id -o tsv)
          
          # Use existing Public IP from AKS
          echo "ğŸ”— Using existing Public IP from previous step"
          PUBLIC_IP_NAME="${{ steps.get-ip.outputs.ip_name }}"
          PUBLIC_IP_RG="${{ steps.get-ip.outputs.ip_resource_group }}"
          
          # Move Public IP to Application Gateway resource group (if different)
          if [ "$PUBLIC_IP_RG" != "${{ env.AZURE_RESOURCE_GROUP }}" ]; then
            echo "ğŸ“¦ Moving Public IP to Application Gateway resource group..."
            az resource move \
              --destination-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --ids $(az network public-ip show \
                --name $PUBLIC_IP_NAME \
                --resource-group $PUBLIC_IP_RG \
                --query id -o tsv) || echo "âš ï¸ Could not move IP, will use from original RG"
            PUBLIC_IP_RG="${{ env.AZURE_RESOURCE_GROUP }}"
          fi
          
          PUBLIC_IP_ID=$(az network public-ip show \
            --resource-group $PUBLIC_IP_RG \
            --name $PUBLIC_IP_NAME \
            --query id -o tsv)
          
          # Create Application Gateway
          az network application-gateway create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --location ${{ env.LOCATION }} \
            --sku ${{ github.event.inputs.app_gateway_sku }} \
            --capacity 2 \
            --vnet-name ${{ env.VNET_NAME }} \
            --subnet $SUBNET_ID \
            --public-ip-address $PUBLIC_IP_ID \
            --http-settings-cookie-based-affinity Disabled \
            --frontend-port 80 \
            --http-settings-port 80 \
            --http-settings-protocol Http \
            --priority 100 \
            --tags Environment=${{ github.event.inputs.environment }} ManagedBy=GitHub-Actions
          
          echo "âœ… Application Gateway created"

      - name: ğŸ›¡ï¸ Configure WAF Policy
        if: github.event.inputs.app_gateway_sku == 'WAF_v2'
        run: |
          echo "ğŸ›¡ï¸ Configuring WAF policy..."
          
          # Create WAF policy
          az network application-gateway waf-policy create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --location ${{ env.LOCATION }}
          
          # Configure WAF settings
          az network application-gateway waf-policy policy-setting update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --policy-name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --mode ${{ github.event.inputs.waf_mode }} \
            --state Enabled \
            --max-request-body-size-in-kb 128 \
            --file-upload-limit-in-mb 100
          
          # Associate WAF policy with Application Gateway
          az network application-gateway update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --set firewallPolicy.id=$(az network application-gateway waf-policy show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
              --query id -o tsv)
          
          echo "âœ… WAF policy configured"

      - name: ğŸ”§ Install AGIC (Application Gateway Ingress Controller)
        run: |
          echo "ğŸ”§ Installing AGIC..."
          
          # Enable AGIC add-on on AKS
          az aks enable-addons \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --addons ingress-appgw \
            --appgw-id $(az network application-gateway show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.APP_GATEWAY_NAME }} \
              --query id -o tsv) || echo "âš ï¸ AGIC may already be enabled"
          
          echo "âœ… AGIC configured"

      - name: ğŸ“Š Verify Application Gateway installation
        run: |
          echo "======================================"
          echo "ğŸ›¡ï¸ Application Gateway Summary"
          echo "======================================"
          echo ""
          
          echo "ğŸŒ Application Gateway:"
          az network application-gateway show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }} \
            --query "{name:name,sku:sku.name,tier:sku.tier,capacity:sku.capacity,provisioningState:provisioningState}" \
            -o table
          echo ""
          
          echo "ğŸŒ Public IP (reused from AKS):"
          echo "IP Address: ${{ steps.get-ip.outputs.ip_address }}"
          echo ""
          echo "âš ï¸  IMPORTANT: Configure your DNS to point to this IP!"
          echo "   Example (no-ip.com): dx02.no-ip.org â†’ ${{ steps.get-ip.outputs.ip_address }}"
          echo ""
          
          echo "ğŸ›¡ï¸ WAF Policy:"
          az network application-gateway waf-policy show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.APP_GATEWAY_NAME }}-waf-policy \
            --query "{name:name,mode:policySettings.mode,state:policySettings.state}" \
            -o table 2>/dev/null || echo "WAF policy not configured"
          echo ""
          
          echo "âœ… Application Gateway is ready!"

  configure-ingress:
    name: ğŸ”— Configure Ingress with HTTPS
    runs-on: ubuntu-latest
    needs: [deploy-cert-manager, deploy-application-gateway]
    if: |
      always() && 
      (needs.deploy-cert-manager.result == 'success' || needs.deploy-cert-manager.result == 'skipped') &&
      (needs.deploy-application-gateway.result == 'success' || needs.deploy-application-gateway.result == 'skipped')
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ¯ Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: ğŸ”— Update DX02 Ingress with HTTPS and cert-manager
        if: github.event.inputs.install_cert_manager == 'true'
        run: |
          ISSUER_NAME="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'letsencrypt-prod' || 'letsencrypt-staging' }}"
          
          echo "ğŸ”— Updating DX02 Ingress with HTTPS support..."
          echo "Domain: ${{ github.event.inputs.domain_name }}"
          
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: dx02
            namespace: dx02
            annotations:
              cert-manager.io/cluster-issuer: $ISSUER_NAME
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
              nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
              nginx.ingress.kubernetes.io/proxy-body-size: "10m"
              nginx.ingress.kubernetes.io/rate-limit: "100"
          spec:
            ingressClassName: nginx
            tls:
            - hosts:
              - ${{ github.event.inputs.domain_name }}
              secretName: dx02-tls-secret
            rules:
            - host: ${{ github.event.inputs.domain_name }}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: dx02-service
                      port:
                        number: 80
          EOF
          
          echo "âœ… Ingress updated with HTTPS for domain: ${{ github.event.inputs.domain_name }}"

      - name: ğŸ“Š Display final summary
        run: |
          echo "======================================"
          echo "ğŸ‰ Security Infrastructure Deployed!"
          echo "======================================"
          echo ""
          
          if [[ "${{ github.event.inputs.install_cert_manager }}" == "true" ]]; then
            echo "ğŸ“œ cert-manager: âœ… Installed"
            ISSUER_NAME="${{ github.event.inputs.use_letsencrypt_prod == 'true' && 'letsencrypt-prod' || 'letsencrypt-staging' }}"
            echo "   ClusterIssuer: $ISSUER_NAME"
            echo "   Email: ${{ github.event.inputs.letsencrypt_email }}"
            echo "   Domain: ${{ github.event.inputs.domain_name }}"
          fi
          
          if [[ "${{ github.event.inputs.deploy_app_gateway }}" == "true" ]]; then
            echo ""
            echo "ğŸ›¡ï¸ Application Gateway: âœ… Deployed"
            echo "   SKU: ${{ github.event.inputs.app_gateway_sku }}"
            echo "   WAF Mode: ${{ github.event.inputs.waf_mode }}"
            echo "   Public IP: 48.194.53.219 (reused from AKS)"
          fi
          
          echo ""
          echo "======================================"
          echo "ğŸ“ IMPORTANT - Configure DNS NOW:"
          echo "======================================"
          echo ""
          echo "1ï¸âƒ£ Go to no-ip.com"
          echo "2ï¸âƒ£ Create/Update hostname: ${{ github.event.inputs.domain_name }}"
          echo "3ï¸âƒ£ Point to IP: 48.194.53.219"
          echo ""
          echo "4ï¸âƒ£ Wait 5-10 minutes for cert-manager to issue certificate"
          echo "5ï¸âƒ£ Access: https://${{ github.event.inputs.domain_name }}"
          echo ""
          echo "âœ… Deployment complete!"
